
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stevenchiu7311/melody/config.go (100.0%)</option>
				
				<option value="file1">github.com/stevenchiu7311/melody/hub.go (49.6%)</option>
				
				<option value="file2">github.com/stevenchiu7311/melody/melody.go (41.6%)</option>
				
				<option value="file3">github.com/stevenchiu7311/melody/session.go (67.4%)</option>
				
				<option value="file4">github.com/stevenchiu7311/melody/util.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package melody

import "time"

// UseRedisPool - USE REDIS POOL
var UseRedisPool = true

// DebugRedisPoolConn -
var DebugRedisPoolConn = 0

// RedisRcvConn -
var RedisRcvConn = 10

// RedisRcvRetryInterval -
var RedisRcvRetryInterval int = 1

// RedisURL -
var RedisURL = "127.0.0.1:6379"

// Config melody configuration struct.
type Config struct {
        WriteWait         time.Duration // Milliseconds until write times out.
        PongWait          time.Duration // Timeout for waiting on pong.
        PingPeriod        time.Duration // Milliseconds between pings.
        MaxMessageSize    int64         // Maximum size in bytes of a message.
        MessageBufferSize int           // The max amount of messages that can be in a sessions buffer before it starts dropping them.
}

func newConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                WriteWait:         60 * time.Second,
                PongWait:          60 * time.Second,
                PingPeriod:        (60 * time.Second * 9) / 10,
                MaxMessageSize:    512,
                MessageBufferSize: 256,
        }
}</span>

// StatsRedis -
type StatsRedis struct {
        URL            string
        MaxIdle        int
        MaxActive      int
        ConnectTimeout time.Duration
        ReadTimeout    time.Duration
        WriteTimeout   time.Duration
}

func newStatsRedis(url string) *StatsRedis <span class="cov8" title="1">{
        return &amp;StatsRedis{
                URL:            url,
                MaxIdle:        5,
                MaxActive:      20,
                ConnectTimeout: 10 * time.Second,
                ReadTimeout:    0,
                WriteTimeout:   0,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package melody

import (
        "encoding/json"
        "log"
        "sync"
        "time"
        "unsafe"

        "github.com/gomodule/redigo/redis"
)

var (
        gRedisConn = func(uri string) (redis.Conn, error) <span class="cov8" title="1">{
                redisConn, err := redis.Dial("tcp", uri,
                        redis.DialConnectTimeout(time.Duration(10*time.Second)),
                        redis.DialReadTimeout(time.Duration(0)),
                        redis.DialWriteTimeout(time.Duration(0)))
                return redisConn, err
        }</span>
        forkInHub       = true
        routeMapping    = true
        bucketDebugDump = false
)

type hub struct {
        sessions       map[*Session]bool
        broadcast      []chan *envelope
        register       chan *Session
        exit           chan *envelope
        unregister     chan *Session
        persistRecv    []chan bool
        open           bool
        rwmutex        *sync.RWMutex
        redisPool      *redis.Pool
        redisConn      redis.Conn
        pubRedisConn   redis.Conn
        pubSubConn     []*redis.PubSubConn
        regMutex       *sync.RWMutex
        allocConnMutex *sync.Mutex
        routeMaps      []map[interface{}]map[*Session]*Session
}

func newRedisPool() *redis.Pool <span class="cov8" title="1">{
        statRedis := newStatsRedis(RedisURL)
        numRedisConn := statRedis.MaxActive
        if DebugRedisPoolConn != 0 </span><span class="cov0" title="0">{
                numRedisConn = DebugRedisPoolConn
        }</span>
        <span class="cov8" title="1">log.Println("Configured max active redis conn:", numRedisConn)
        return &amp;redis.Pool{
                MaxIdle:   statRedis.MaxIdle,
                MaxActive: numRedisConn,
                Dial: func() (redis.Conn, error) </span><span class="cov0" title="0">{
                        c, err := redis.Dial("tcp", statRedis.URL,
                                redis.DialConnectTimeout(time.Duration(statRedis.ConnectTimeout)),
                                redis.DialReadTimeout(time.Duration(statRedis.ReadTimeout)),
                                redis.DialWriteTimeout(time.Duration(statRedis.WriteTimeout)))
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return c, nil</span>
                },
                // Use the TestOnBorrow function to check the health of an idle connection
                // before the connection is returned to the application.
                TestOnBorrow: func(c redis.Conn, t time.Time) error <span class="cov0" title="0">{
                        if time.Since(t) &lt; time.Minute </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">_, err := c.Do("PING")
                        return err</span>
                },
                IdleTimeout: 300 * time.Second,
                // If Wait is true and the pool is at the MaxActive limit,
                // then Get() waits for a connection to be returned to the pool before returning
                Wait: true,
        }
}
func newHub() *hub <span class="cov8" title="1">{
        redisPool := newRedisPool()
        redisURI := RedisURL
        log.Printf("Connect to redis server:[%s]\n", redisURI)
        log.Println("Configured max recv redis conn:", RedisRcvConn)
        routeMaps := make([]map[interface{}]map[*Session]*Session, RedisRcvConn)
        pubSubConn := make([]*redis.PubSubConn, RedisRcvConn)
        broadcast := make([]chan *envelope, RedisRcvConn)
        persistRecv := make([]chan bool, RedisRcvConn)
        regRefMaps := make([]map[string]*int, RedisRcvConn)
        for i := 0; i &lt; RedisRcvConn; i++ </span><span class="cov8" title="1">{
                redisConn, err := gRedisConn(redisURI)
                pubSubConn[i] = &amp;redis.PubSubConn{Conn: redisConn}
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">broadcast[i] = make(chan *envelope)
                regRefMaps[i] = make(map[string]*int)
                routeMaps[i] = make(map[interface{}]map[*Session]*Session)
                persistRecv[i] = make(chan bool)</span>
        }

        //defer redisConn.Close()

        //defer pubSubConn.Close()

        <span class="cov8" title="1">return &amp;hub{
                sessions:    make(map[*Session]bool),
                broadcast:   broadcast,
                register:    make(chan *Session),
                unregister:  make(chan *Session),
                exit:        make(chan *envelope),
                persistRecv: persistRecv,
                open:        true,
                rwmutex:     &amp;sync.RWMutex{},
                redisPool:   redisPool,
                pubSubConn:  pubSubConn,
                regMutex:    &amp;sync.RWMutex{},
                routeMaps:   routeMaps,
        }</span>
}

func (h *hub) run(index int) <span class="cov8" title="1">{
loop:
        for </span><span class="cov8" title="1">{
                select </span>{
                case s := &lt;-h.register:<span class="cov8" title="1">
                        h.rwmutex.Lock()
                        h.sessions[s] = true
                        h.rwmutex.Unlock()</span>
                case s := &lt;-h.unregister:<span class="cov8" title="1">
                        h.rwmutex.Lock()
                        if _, ok := h.sessions[s]; ok </span><span class="cov8" title="1">{
                                delete(h.sessions, s)
                        }</span>
                        <span class="cov8" title="1">h.rwmutex.Unlock()</span>
                case m := &lt;-h.broadcast[index]:<span class="cov8" title="1">
                        handler := func() </span><span class="cov8" title="1">{
                                h.rwmutex.RLock()
                                if false </span><span class="cov0" title="0">{
                                        log.Println(m)
                                }</span>
                                <span class="cov8" title="1">if routeMapping </span><span class="cov8" title="1">{
                                        h.regMutex.Lock()
                                        for s := range h.routeMaps[index][m.To] </span><span class="cov8" title="1">{
                                                if m.filter != nil </span><span class="cov0" title="0">{
                                                        if m.filter(s) </span><span class="cov0" title="0">{
                                                                s.writeMessage(m)
                                                        }</span>
                                                } else<span class="cov8" title="1"> {
                                                        s.writeMessage(m)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">h.regMutex.Unlock()</span>
                                } else<span class="cov0" title="0"> {
                                        for s := range h.sessions </span><span class="cov0" title="0">{
                                                if m.filter != nil </span><span class="cov0" title="0">{
                                                        if m.filter(s) </span><span class="cov0" title="0">{
                                                                s.writeMessage(m)
                                                        }</span>
                                                } else<span class="cov0" title="0"> {
                                                        s.writeMessage(m)
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">h.rwmutex.RUnlock()</span>
                        }
                        <span class="cov8" title="1">if forkInHub </span><span class="cov8" title="1">{
                                go handler()
                        }</span> else<span class="cov0" title="0"> {
                                handler()
                        }</span>
                case m := &lt;-h.exit:<span class="cov8" title="1">
                        h.rwmutex.Lock()
                        for s := range h.sessions </span><span class="cov8" title="1">{
                                s.writeMessage(m)
                                delete(h.sessions, s)
                                s.Close()
                        }</span>
                        <span class="cov8" title="1">h.open = false
                        h.rwmutex.Unlock()
                        for i := 0; i &lt; RedisRcvConn; i++ </span><span class="cov8" title="1">{
                                h.persistRecv[i] &lt;- false
                        }</span>
                        <span class="cov0" title="0">break loop</span>
                }
        }
}

func (h *hub) closed() bool <span class="cov8" title="1">{
        h.rwmutex.RLock()
        defer h.rwmutex.RUnlock()
        return !h.open
}</span>

func (h *hub) len() int <span class="cov8" title="1">{
        h.rwmutex.RLock()
        defer h.rwmutex.RUnlock()

        return len(h.sessions)
}</span>

func (h *hub) readRedisConn(index int) <span class="cov8" title="1">{
        if bucketDebugDump </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                h.regMutex.Lock()
                                if len(h.routeMaps[index]) &gt; 0 </span><span class="cov0" title="0">{
                                        log.Println("-------------------------------------")
                                        log.Printf("h.routeMaps[%d]:%d", index, len(h.routeMaps[index]))
                                }</span>
                                <span class="cov0" title="0">h.regMutex.Unlock()
                                time.Sleep(5 * time.Second)</span>
                        }
                }()
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                switch v := h.pubSubConn[index].Receive().(type) </span>{
                case redis.Message:<span class="cov0" title="0">
                        handler := func() </span><span class="cov0" title="0">{
                                e := &amp;envelope{}
                                json.Unmarshal(v.Data, e)
                                message := &amp;envelope{T: e.T, Msg: []byte(e.Msg), filter: func(s *Session) bool </span><span class="cov0" title="0">{
                                        if e.From != 0 &amp;&amp; e.From == uintptr(unsafe.Pointer(s)) </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                        <span class="cov0" title="0">if routeMapping </span><span class="cov0" title="0">{
                                                return true
                                        }</span>

                                        <span class="cov0" title="0">s.regMapMutex.RLock()
                                        for _, element := range s.RegMap </span><span class="cov0" title="0">{
                                                if element == e.To </span><span class="cov0" title="0">{
                                                        s.regMapMutex.RUnlock()
                                                        return true
                                                }</span>
                                        }
                                        <span class="cov0" title="0">s.regMapMutex.RUnlock()
                                        return false</span>
                                }, To: e.To}

                                <span class="cov0" title="0">h.broadcast[index] &lt;- message</span>
                        }
                        <span class="cov0" title="0">if forkInHub </span><span class="cov0" title="0">{
                                go handler()
                        }</span> else<span class="cov0" title="0"> {
                                handler()
                        }</span>
                case redis.Subscription:<span class="cov8" title="1">
                        if EnableDebug </span><span class="cov0" title="0">{
                                log.Printf("subscription message:[%s] count:[%d] recvThread[%d]\n", v.Channel, v.Count, index)
                        }</span>
                case error:<span class="cov0" title="0">
                        log.Println("error pub/sub on connection, delivery has stopped, err[", v, "]")
                        var persistRecv = true
                        select </span>{
                        case persistRecv = &lt;-h.persistRecv[index]:<span class="cov0" title="0"></span>
                        case &lt;-time.After(time.Duration(RedisRcvRetryInterval) * time.Second):<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">if persistRecv </span><span class="cov0" title="0">{
                                redisURI := RedisURL
                                redisConn, err := gRedisConn(redisURI)
                                h.pubSubConn[index] = &amp;redis.PubSubConn{Conn: redisConn}
                                if err == nil </span><span class="cov0" title="0">{
                                        log.Println("Re-connect redis")
                                }</span> else<span class="cov0" title="0"> {
                                        continue</span>
                                }

                                <span class="cov0" title="0">h.regMutex.Lock()
                                for key := range h.routeMaps[index] </span><span class="cov0" title="0">{
                                        if err := h.pubSubConn[index].Subscribe(key); err != nil </span><span class="cov0" title="0">{
                                                h.regMutex.Unlock()
                                                panic(err)</span>
                                        }
                                }
                                <span class="cov0" title="0">h.regMutex.Unlock()</span>
                        } else<span class="cov0" title="0"> {
                                return
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package melody

import (
        "encoding/json"
        "errors"
        "log"
        "net/http"
        "runtime"
        "sync"
        "unsafe"

        "github.com/gorilla/websocket"
)

// Close codes defined in RFC 6455, section 11.7.
// Duplicate of codes from gorilla/websocket for convenience.
const (
        CloseNormalClosure           = 1000
        CloseGoingAway               = 1001
        CloseProtocolError           = 1002
        CloseUnsupportedData         = 1003
        CloseNoStatusReceived        = 1005
        CloseAbnormalClosure         = 1006
        CloseInvalidFramePayloadData = 1007
        ClosePolicyViolation         = 1008
        CloseMessageTooBig           = 1009
        CloseMandatoryExtension      = 1010
        CloseInternalServerErr       = 1011
        CloseServiceRestart          = 1012
        CloseTryAgainLater           = 1013
        CloseTLSHandshake            = 1015
)

// Duplicate of codes from gorilla/websocket for convenience.
var validReceivedCloseCodes = map[int]bool{
        // see http://www.iana.org/assignments/websocket/websocket.xhtml#close-code-number

        CloseNormalClosure:           true,
        CloseGoingAway:               true,
        CloseProtocolError:           true,
        CloseUnsupportedData:         true,
        CloseNoStatusReceived:        false,
        CloseAbnormalClosure:         false,
        CloseInvalidFramePayloadData: true,
        ClosePolicyViolation:         true,
        CloseMessageTooBig:           true,
        CloseMandatoryExtension:      true,
        CloseInternalServerErr:       true,
        CloseServiceRestart:          true,
        CloseTryAgainLater:           true,
        CloseTLSHandshake:            false,
}

// Keep alive const
const (
        KeepAliveOff = iota
        KeepAlivePing
        KeepAlivePong
)

// KeepAliveMode - Keep alive mode type
type KeepAliveMode int

type handleMessageFunc func(*Session, []byte)
type handleErrorFunc func(*Session, error)
type handleCloseFunc func(*Session, int, string) error
type handleSessionFunc func(*Session)
type filterFunc func(*Session) bool

// Melody implements a websocket manager.
type Melody struct {
        Config                   *Config
        Upgrader                 *websocket.Upgrader
        messageHandler           handleMessageFunc
        messageHandlerBinary     handleMessageFunc
        messageSentHandler       handleMessageFunc
        messageSentHandlerBinary handleMessageFunc
        errorHandler             handleErrorFunc
        closeHandler             handleCloseFunc
        connectHandler           handleSessionFunc
        disconnectHandler        handleSessionFunc
        pingHandler              handleSessionFunc
        pongHandler              handleSessionFunc
        hub                      *hub
        KeepAlive                KeepAliveMode
        pubMutex                 sync.RWMutex
        debugInfo                DebugInfo
}

// DebugInfo -
type DebugInfo struct {
        UserCountMutex sync.Mutex
        UserCount      int
}

// EnableDebug -
var EnableDebug = false

// New creates a new melody instance with default Upgrader and Config.
func New() *Melody <span class="cov8" title="1">{
        upgrader := &amp;websocket.Upgrader{
                ReadBufferSize:  1024,
                WriteBufferSize: 1024,
                CheckOrigin:     func(r *http.Request) bool </span><span class="cov8" title="1">{ return true }</span>,
        }

        <span class="cov8" title="1">hub := newHub()

        for i := 0; i &lt; RedisRcvConn; i++ </span><span class="cov8" title="1">{
                go hub.run(i)
                go hub.readRedisConn(i)
        }</span>

        <span class="cov8" title="1">return &amp;Melody{
                Config:                   newConfig(),
                Upgrader:                 upgrader,
                messageHandler:           func(*Session, []byte) </span>{<span class="cov8" title="1">}</span>,
                messageHandlerBinary:     func(*Session, []byte) {<span class="cov0" title="0">}</span>,
                messageSentHandler:       func(*Session, []byte) {<span class="cov8" title="1">}</span>,
                messageSentHandlerBinary: func(*Session, []byte) {<span class="cov8" title="1">}</span>,
                errorHandler:             func(*Session, error) {<span class="cov8" title="1">}</span>,
                closeHandler:             nil,
                connectHandler:           func(*Session) {<span class="cov8" title="1">}</span>,
                disconnectHandler:        func(*Session) {<span class="cov8" title="1">}</span>,
                pingHandler:              func(*Session) {<span class="cov0" title="0">}</span>,
                pongHandler:              func(*Session) {<span class="cov0" title="0">}</span>,
                hub:                      hub,
                debugInfo:                DebugInfo{},
        }
}

// HandleConnect fires fn when a session connects.
func (m *Melody) HandleConnect(fn func(*Session)) <span class="cov8" title="1">{
        m.connectHandler = fn
}</span>

// HandleDisconnect fires fn when a session disconnects.
func (m *Melody) HandleDisconnect(fn func(*Session)) <span class="cov8" title="1">{
        m.disconnectHandler = fn
}</span>

// HandlePing fires fn when a ping is received from a session.
func (m *Melody) HandlePing(fn func(*Session)) <span class="cov0" title="0">{
        m.pingHandler = fn
}</span>

// HandlePong fires fn when a pong is received from a session.
func (m *Melody) HandlePong(fn func(*Session)) <span class="cov8" title="1">{
        m.pongHandler = fn
}</span>

// HandleMessage fires fn when a text message comes in.
func (m *Melody) HandleMessage(fn func(*Session, []byte)) <span class="cov8" title="1">{
        m.messageHandler = fn
}</span>

// HandleMessageBinary fires fn when a binary message comes in.
func (m *Melody) HandleMessageBinary(fn func(*Session, []byte)) <span class="cov8" title="1">{
        m.messageHandlerBinary = fn
}</span>

// HandleSentMessage fires fn when a text message is successfully sent.
func (m *Melody) HandleSentMessage(fn func(*Session, []byte)) <span class="cov0" title="0">{
        m.messageSentHandler = fn
}</span>

// HandleSentMessageBinary fires fn when a binary message is successfully sent.
func (m *Melody) HandleSentMessageBinary(fn func(*Session, []byte)) <span class="cov0" title="0">{
        m.messageSentHandlerBinary = fn
}</span>

// HandleError fires fn when a session has an error.
func (m *Melody) HandleError(fn func(*Session, error)) <span class="cov8" title="1">{
        m.errorHandler = fn
}</span>

// HandleClose sets the handler for close messages received from the session.
// The code argument to h is the received close code or CloseNoStatusReceived
// if the close message is empty. The default close handler sends a close frame
// back to the session.
//
// The application must read the connection to process close messages as
// described in the section on Control Frames above.
//
// The connection read methods return a CloseError when a close frame is
// received. Most applications should handle close messages as part of their
// normal error handling. Applications should only set a close handler when the
// application must perform some action before sending a close frame back to
// the session.
func (m *Melody) HandleClose(fn func(*Session, int, string) error) <span class="cov0" title="0">{
        if fn != nil </span><span class="cov0" title="0">{
                m.closeHandler = fn
        }</span>
}

// HandleRequest upgrades http requests to websocket connections and dispatches them to be handled by the melody instance.
func (m *Melody) HandleRequest(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        return m.HandleRequestWithKeys(w, r, nil)
}</span>

// HandleRequestWithKeys does the same as HandleRequest but populates session.Keys with keys.
func (m *Melody) HandleRequestWithKeys(w http.ResponseWriter, r *http.Request, keys map[string]interface{}) error <span class="cov8" title="1">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is closed")
        }</span>

        <span class="cov8" title="1">conn, err := m.Upgrader.Upgrade(w, r, nil)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if EnableDebug </span><span class="cov0" title="0">{
                m.debugInfo.UserCountMutex.Lock()
                m.debugInfo.UserCount++
                log.Print("Enter User count:[", m.debugInfo.UserCount, "]", " NumGoroutine:[", runtime.NumGoroutine(), "]")
                m.debugInfo.UserCountMutex.Unlock()
        }</span>

        <span class="cov8" title="1">session := &amp;Session{
                Request:     r,
                Keys:        keys,
                conn:        conn,
                output:      make(chan *envelope, m.Config.MessageBufferSize),
                melody:      m,
                open:        true,
                rwmutex:     &amp;sync.RWMutex{},
                RegMap:      make(map[string]interface{}),
                regMapMutex: &amp;sync.RWMutex{},
        }

        m.hub.register &lt;- session

        m.connectHandler(session)

        go session.writePump()

        session.readPump()

        if !m.hub.closed() </span><span class="cov8" title="1">{
                m.hub.unregister &lt;- session
        }</span>

        <span class="cov8" title="1">session.close()

        m.disconnectHandler(session)

        if EnableDebug </span><span class="cov0" title="0">{
                m.debugInfo.UserCountMutex.Lock()
                m.debugInfo.UserCount--
                log.Print("Leave User count:[", m.debugInfo.UserCount, "]", " NumGoroutine:[", runtime.NumGoroutine(), "]")
                m.debugInfo.UserCountMutex.Unlock()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Broadcast broadcasts a text message to all sessions.
func (m *Melody) Broadcast(msg []byte, channel interface{}, messageType int) error <span class="cov8" title="1">{
        return m.BroadcastOthers(nil, msg, channel, messageType)
}</span>

// BroadcastFilter broadcasts a text message to all sessions that fn returns true for.
func (m *Melody) BroadcastFilter(msg []byte, fn func(*Session) bool) error <span class="cov0" title="0">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is closed")
        }</span>

        <span class="cov0" title="0">message := &amp;envelope{T: websocket.TextMessage, Msg: msg, filter: fn}
        m.hub.broadcast[0] &lt;- message

        return nil</span>
}

// BroadcastRemote -
func (m *Melody) BroadcastRemote(msg []byte, channel interface{}, messageType int) error <span class="cov0" title="0">{
        return m.BroadcastOthersRemote(nil, msg, channel, messageType)
}</span>

// BroadcastOthersRemote -
func (m *Melody) BroadcastOthersRemote(s *Session, msg []byte, channel interface{}, messageType int) error <span class="cov0" title="0">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is closed")
        }</span>
        <span class="cov0" title="0">message := &amp;envelope{T: messageType, Msg: msg, To: channel, From: uintptr(unsafe.Pointer(s))}

        if message.To != "" </span><span class="cov0" title="0">{
                content, _ := json.Marshal(*message)

                if UseRedisPool </span><span class="cov0" title="0">{
                        m.pubMutex.Lock()
                        c := m.hub.redisPool.Get()
                        if c != nil </span><span class="cov0" title="0">{
                                c.Do("PUBLISH", message.To, content)
                        }</span>
                        <span class="cov0" title="0">defer c.Close()
                        m.pubMutex.Unlock()</span>
                } else<span class="cov0" title="0"> {
                        m.pubMutex.Lock()
                        if m.hub.pubRedisConn == nil </span><span class="cov0" title="0">{
                                redisURI := RedisURL
                                if c, err := gRedisConn(redisURI); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("error on redis conn. %s\n", err)
                                }</span> else<span class="cov0" title="0"> {
                                        m.hub.pubRedisConn = c
                                }</span>
                        }

                        <span class="cov0" title="0">if m.hub.pubRedisConn != nil </span><span class="cov0" title="0">{
                                m.hub.pubRedisConn.Do("PUBLISH", message.To, content)
                        }</span>
                        <span class="cov0" title="0">m.pubMutex.Unlock()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// BroadcastOthers broadcasts a text message to all sessions except session s.
func (m *Melody) BroadcastOthers(s *Session, msg []byte, channel interface{}, messageType int) error <span class="cov8" title="1">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is closed")
        }</span>

        <span class="cov8" title="1">message := &amp;envelope{T: messageType, Msg: msg, To: channel, From: uintptr(unsafe.Pointer(s))}
        m.hub.regMutex.RLock()
        bucketIdxs := make([]int, 0)
        for i, maps := range m.hub.routeMaps </span><span class="cov8" title="1">{
                _, ok := maps[channel]
                if ok </span><span class="cov8" title="1">{
                        bucketIdxs = append(bucketIdxs, i)
                }</span>
        }
        <span class="cov8" title="1">m.hub.regMutex.RUnlock()
        for _, bucketIdx := range bucketIdxs </span><span class="cov8" title="1">{
                m.hub.broadcast[bucketIdx] &lt;- message
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BroadcastMultiple broadcasts a text message to multiple sessions given in the sessions slice.
func (m *Melody) BroadcastMultiple(msg []byte, sessions []*Session) error <span class="cov0" title="0">{
        for _, sess := range sessions </span><span class="cov0" title="0">{
                if writeErr := sess.Write(msg); writeErr != nil </span><span class="cov0" title="0">{
                        return writeErr
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// BroadcastBinary broadcasts a binary message to all sessions.
func (m *Melody) BroadcastBinary(msg []byte) error <span class="cov0" title="0">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is closed")
        }</span>

        <span class="cov0" title="0">message := &amp;envelope{T: websocket.BinaryMessage, Msg: msg}
        m.hub.broadcast[0] &lt;- message

        return nil</span>
}

// BroadcastBinaryFilter broadcasts a binary message to all sessions that fn returns true for.
func (m *Melody) BroadcastBinaryFilter(msg []byte, fn func(*Session) bool) error <span class="cov0" title="0">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is closed")
        }</span>

        <span class="cov0" title="0">message := &amp;envelope{T: websocket.BinaryMessage, Msg: msg, filter: fn}
        m.hub.broadcast[0] &lt;- message

        return nil</span>
}

// BroadcastBinaryOthers broadcasts a binary message to all sessions except session s.
func (m *Melody) BroadcastBinaryOthers(msg []byte, s *Session) error <span class="cov0" title="0">{
        return m.BroadcastBinaryFilter(msg, func(q *Session) bool </span><span class="cov0" title="0">{
                return s != q
        }</span>)
}

// Close closes the melody instance and all connected sessions.
func (m *Melody) Close() error <span class="cov8" title="1">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is already closed")
        }</span>

        <span class="cov8" title="1">m.hub.exit &lt;- &amp;envelope{T: websocket.CloseMessage, Msg: []byte{}}

        return nil</span>
}

// CloseWithMsg closes the melody instance with the given close payload and all connected sessions.
// Use the FormatCloseMessage function to format a proper close message payload.
func (m *Melody) CloseWithMsg(msg []byte) error <span class="cov0" title="0">{
        if m.hub.closed() </span><span class="cov0" title="0">{
                return errors.New("melody instance is already closed")
        }</span>

        <span class="cov0" title="0">m.hub.exit &lt;- &amp;envelope{T: websocket.CloseMessage, Msg: msg}

        return nil</span>
}

// Len return the number of connected sessions.
func (m *Melody) Len() int <span class="cov8" title="1">{
        return m.hub.len()
}</span>

// IsClosed returns the status of the melody instance.
func (m *Melody) IsClosed() bool <span class="cov0" title="0">{
        return m.hub.closed()
}</span>

// FormatCloseMessage formats closeCode and text as a WebSocket close message.
func FormatCloseMessage(closeCode int, text string) []byte <span class="cov0" title="0">{
        return websocket.FormatCloseMessage(closeCode, text)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package melody

import (
        "errors"
        "log"
        "net/http"
        "sync"
        "time"
        "unsafe"

        "github.com/gorilla/websocket"
)

// Session wrapper around websocket connections.
type Session struct {
        Request     *http.Request
        Keys        map[string]interface{}
        conn        *websocket.Conn
        output      chan *envelope
        melody      *Melody
        open        bool
        rwmutex     *sync.RWMutex
        RegMap      map[string]interface{}
        regMapMutex *sync.RWMutex
}

func (s *Session) writeMessage(message *envelope) <span class="cov8" title="1">{
        if s.closed() </span><span class="cov0" title="0">{
                s.melody.errorHandler(s, errors.New("tried to write to closed a session"))
                return
        }</span>

        <span class="cov8" title="1">select </span>{
        case s.output &lt;- message:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                s.melody.errorHandler(s, errors.New("session message buffer is full"))</span>
        }
}

func (s *Session) writeRaw(message *envelope) error <span class="cov8" title="1">{
        if s.closed() </span><span class="cov8" title="1">{
                return errors.New("tried to write to a closed session")
        }</span>

        <span class="cov8" title="1">if s.melody.KeepAlive != KeepAliveOff </span><span class="cov0" title="0">{
                s.conn.SetWriteDeadline(time.Now().Add(s.melody.Config.WriteWait))
        }</span>
        <span class="cov8" title="1">err := s.conn.WriteMessage(message.T, message.Msg)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Session) closed() bool <span class="cov8" title="1">{
        s.rwmutex.RLock()
        defer s.rwmutex.RUnlock()

        return !s.open
}</span>

func (s *Session) close() <span class="cov8" title="1">{
        if !s.closed() </span><span class="cov8" title="1">{
                s.rwmutex.Lock()
                s.open = false
                s.conn.Close()
                close(s.output)
                s.rwmutex.Unlock()
        }</span>
}

func (s *Session) ping() <span class="cov0" title="0">{
        s.writeRaw(&amp;envelope{T: websocket.PingMessage, Msg: []byte{}})
}</span>

func (s *Session) pong() <span class="cov0" title="0">{
        s.writeRaw(&amp;envelope{T: websocket.PongMessage, Msg: []byte{}})
}</span>

func (s *Session) writePump() <span class="cov8" title="1">{
        ticker := time.NewTicker(s.melody.Config.PingPeriod)
        defer ticker.Stop()

loop:
        for </span><span class="cov8" title="1">{
                select </span>{
                case msg, ok := &lt;-s.output:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                break loop</span>
                        }

                        <span class="cov8" title="1">err := s.writeRaw(msg)

                        if err != nil </span><span class="cov8" title="1">{
                                s.melody.errorHandler(s, err)
                                break loop</span>
                        }

                        <span class="cov8" title="1">if msg.T == websocket.CloseMessage </span><span class="cov8" title="1">{
                                break loop</span>
                        }

                        <span class="cov8" title="1">if msg.T == websocket.TextMessage </span><span class="cov8" title="1">{
                                s.melody.messageSentHandler(s, msg.Msg)
                        }</span>

                        <span class="cov8" title="1">if msg.T == websocket.BinaryMessage </span><span class="cov8" title="1">{
                                s.melody.messageSentHandlerBinary(s, msg.Msg)
                        }</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if s.melody.KeepAlive == KeepAlivePing </span><span class="cov0" title="0">{
                                s.ping()
                        }</span>
                }
        }
}

func (s *Session) readPump() <span class="cov8" title="1">{
        s.conn.SetReadLimit(s.melody.Config.MaxMessageSize)
        if s.melody.KeepAlive != KeepAliveOff </span><span class="cov8" title="1">{
                s.conn.SetReadDeadline(time.Now().Add(s.melody.Config.PongWait))
                if s.melody.KeepAlive == KeepAlivePong </span><span class="cov8" title="1">{
                        s.conn.SetPingHandler(func(string) error </span><span class="cov0" title="0">{
                                s.conn.SetReadDeadline(time.Now().Add(s.melody.Config.PongWait))
                                s.melody.pingHandler(s)
                                s.pong()
                                return nil
                        }</span>)
                }
                <span class="cov8" title="1">if s.melody.KeepAlive == KeepAlivePing </span><span class="cov8" title="1">{
                        s.conn.SetPongHandler(func(string) error </span><span class="cov8" title="1">{
                                s.conn.SetReadDeadline(time.Now().Add(s.melody.Config.PongWait))
                                s.melody.pongHandler(s)
                                return nil
                        }</span>)
                }
        }

        <span class="cov8" title="1">if s.melody.closeHandler != nil </span><span class="cov0" title="0">{
                s.conn.SetCloseHandler(func(code int, text string) error </span><span class="cov0" title="0">{
                        return s.melody.closeHandler(s, code, text)
                }</span>)
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                t, message, err := s.conn.ReadMessage()

                if err != nil </span><span class="cov8" title="1">{
                        s.melody.errorHandler(s, err)
                        break</span>
                }

                <span class="cov8" title="1">if t == websocket.TextMessage </span><span class="cov8" title="1">{
                        s.melody.messageHandler(s, message)
                }</span>

                <span class="cov8" title="1">if t == websocket.BinaryMessage </span><span class="cov8" title="1">{
                        s.melody.messageHandlerBinary(s, message)
                }</span>

                <span class="cov8" title="1">if s.melody.KeepAlive != KeepAliveOff </span><span class="cov8" title="1">{
                        s.conn.SetReadDeadline(time.Now().Add(s.melody.Config.PongWait))
                }</span>
        }
}

// Write writes message to session.
func (s *Session) Write(msg []byte) error <span class="cov8" title="1">{
        if s.closed() </span><span class="cov8" title="1">{
                return errors.New("session is closed")
        }</span>

        <span class="cov8" title="1">s.writeMessage(&amp;envelope{T: websocket.TextMessage, Msg: msg})

        return nil</span>
}

// WriteBinary writes a binary message to session.
func (s *Session) WriteBinary(msg []byte) error <span class="cov8" title="1">{
        if s.closed() </span><span class="cov0" title="0">{
                return errors.New("session is closed")
        }</span>

        <span class="cov8" title="1">s.writeMessage(&amp;envelope{T: websocket.BinaryMessage, Msg: msg})

        return nil</span>
}

// Close closes session.
func (s *Session) Close() error <span class="cov8" title="1">{
        if s.closed() </span><span class="cov0" title="0">{
                return errors.New("session is already closed")
        }</span>

        <span class="cov8" title="1">s.writeMessage(&amp;envelope{T: websocket.CloseMessage, Msg: []byte{}})

        return nil</span>
}

// CloseWithMsg closes the session with the provided payload.
// Use the FormatCloseMessage function to format a proper close message payload.
func (s *Session) CloseWithMsg(msg []byte) error <span class="cov0" title="0">{
        if s.closed() </span><span class="cov0" title="0">{
                return errors.New("session is already closed")
        }</span>

        <span class="cov0" title="0">s.writeMessage(&amp;envelope{T: websocket.CloseMessage, Msg: msg})

        return nil</span>
}

// Set is used to store a new key/value pair exclusivelly for this session.
// It also lazy initializes s.Keys if it was not used previously.
func (s *Session) Set(key string, value interface{}) <span class="cov8" title="1">{
        if s.Keys == nil </span><span class="cov8" title="1">{
                s.Keys = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">s.Keys[key] = value</span>
}

// Get returns the value for the given key, ie: (value, true).
// If the value does not exists it returns (nil, false)
func (s *Session) Get(key string) (value interface{}, exists bool) <span class="cov8" title="1">{
        if s.Keys != nil </span><span class="cov8" title="1">{
                value, exists = s.Keys[key]
        }</span>

        <span class="cov8" title="1">return</span>
}

// MustGet returns the value for the given key if it exists, otherwise it panics.
func (s *Session) MustGet(key string) interface{} <span class="cov8" title="1">{
        if value, exists := s.Get(key); exists </span><span class="cov8" title="1">{
                return value
        }</span>

        <span class="cov0" title="0">panic("Key \"" + key + "\" does not exist")</span>
}

// IsClosed returns the status of the connection.
func (s *Session) IsClosed() bool <span class="cov0" title="0">{
        return s.closed()
}</span>

func (s *Session) Register(regMap map[string]interface{}) <span class="cov8" title="1">{
        retryConn := false
        value := int64(uintptr(unsafe.Pointer(s)))
        bucketIdx := indexFor(value, RedisRcvConn)
        for key, element := range regMap </span><span class="cov8" title="1">{
                s.regMapMutex.Lock()
                s.RegMap[key] = element
                s.regMapMutex.Unlock()

                s.melody.hub.regMutex.Lock()
                _, ok := s.melody.hub.routeMaps[bucketIdx][element.(string)]
                if !ok </span><span class="cov8" title="1">{
                        s.melody.hub.routeMaps[bucketIdx][element.(string)] = make(map[*Session]*Session)
                        if err := s.melody.hub.pubSubConn[bucketIdx].Subscribe(element); err != nil </span><span class="cov0" title="0">{
                                log.Println("Subscribe [", element, "] failed...\n", err)
                                retryConn = true
                        }</span>
                }
                <span class="cov8" title="1">s.melody.hub.routeMaps[bucketIdx][element.(string)][s] = s
                s.melody.hub.regMutex.Unlock()</span>
        }

        <span class="cov8" title="1">if retryConn </span><span class="cov0" title="0">{
                s.signalRetry(bucketIdx)
        }</span>
}

func (s *Session) Unregister(regMap map[string]interface{}) <span class="cov0" title="0">{
        value := int64(uintptr(unsafe.Pointer(s)))
        bucketIdx := indexFor(value, RedisRcvConn)
        for key, element := range regMap </span><span class="cov0" title="0">{
                s.regMapMutex.Lock()
                delete(s.RegMap, key)
                s.regMapMutex.Unlock()

                s.melody.hub.regMutex.Lock()
                _, ok := s.melody.hub.routeMaps[bucketIdx][element.(string)]
                if ok </span><span class="cov0" title="0">{
                        delete(s.melody.hub.routeMaps[bucketIdx][element.(string)], s)
                        if len(s.melody.hub.routeMaps[bucketIdx][element.(string)]) == 0 </span><span class="cov0" title="0">{
                                delete(s.melody.hub.routeMaps[bucketIdx], element.(string))
                                if err := s.melody.hub.pubSubConn[bucketIdx].Unsubscribe(element); err != nil </span><span class="cov0" title="0">{
                                        log.Println("Unsubscribe [", element, "] failed...\n", err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.melody.hub.regMutex.Unlock()</span>
        }
}

func (s *Session) signalRetry(index int) <span class="cov0" title="0">{
        select </span>{
        case s.melody.hub.persistRecv[index] &lt;- true:<span class="cov0" title="0">
                log.Println("Send persistRecv signal...")</span>
        default:<span class="cov0" title="0">
                log.Println("Already being reconnected and drop persistRecv signal...")</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package melody

func indexFor(h int64, length int) int <span class="cov8" title="1">{
        if length &gt; 1 </span><span class="cov8" title="1">{
                return int((h / 100) % (int64(length) - 1))
        }</span>
        <span class="cov0" title="0">return length - 1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
